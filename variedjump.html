<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Infinite Runner with PNG Parallax and TileSprites</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <script src="https://lib.pavlovia.org/psychojs-2021.2.2.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        canvas { display: block; margin: auto; }
    </style>
</head>
<body>
    <script>
        const GAME_WIDTH = 928, GAME_HEIGHT = 793;

        const config = {
            type: Phaser.AUTO, width: GAME_WIDTH, height: GAME_HEIGHT, pixelArt: true,
            physics: { default: 'arcade', arcade: { gravity: { y: 5000 }, debug: true } },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let player, ground, cursors, wasdKeys, foregroundLayer, scoreText;
        let isJumping, smallObstacle, tallObstacle, isAttacking, isDefeated = false;
        let attackKey, hitbox, obstacleSpawnTimer, retryButton, finishButton;
        let spawnDelay = 2000, obstacleSpeed = -400, baseSpeed = 1, parallaxSpeed = 1, score = 0;
        let smallObstacles = [], tallObstacles = [], backgroundLayers = [];
        console.log("ScoreText Initialized:", scoreText);

        const maxSmallObstacles = 4; // Maximum small obstacles at a time
        const maxTallObstacles = 4;  // Maximum tall obstacles at a time
        const baseAnimationFrameRate = 180;  // Base frame rate for animations
        const maxAnimationFrameRate = 480;   // Maximum frame rate cap
        const jumpConfig = { startTime: 0, holdTimeMax: 250, initialVelocity: -1200, holdBoost: -40 };

        function preload() {
    loadBackgroundImages(this);
    loadPlayerSprites(this);
    this.load.image('ground', 'https://examples.phaser.io/assets/sprites/platform.png');
    this.load.image('smallObstacle', 'https://examples.phaser.io/assets/sprites/block.png');

    // Load sword sound and log events to confirm if it loads successfully
    this.load.audio('swordSound', 'https://raw.githubusercontent.com/ML3782/Dissertation-Endless-Runner/main/Miscellaneous/sword_attack.wav');

    // Add event listeners for load success/failure
    this.load.on('filecomplete-audio-swordSound', () => {
        console.log('Sword sound loaded successfully');
    });

    this.load.on('loaderror', (file) => {
        if (file.key === 'swordSound') {
            console.error('Failed to load sword sound.');
        }
    });
}
        
function create() {
    // Reset variables
    smallObstacles = [];
    tallObstacles = [];
    isDefeated = false;
    spawnDelay = 2000;
    obstacleSpeed = -400;
    baseSpeed = 1;
    parallaxSpeed = 1;
    scoreText = this.add.text(GAME_WIDTH / 2, 16, 'Score: 0', { fontSize: '32px', fill: '#FFF' });
    scoreText.setOrigin(0.5, 0); // Center align horizontally
    this.handleAttack = handleAttack.bind(this);

    // Initialize sword sound and set a low volume
    swordSound = this.sound.add('swordSound', { volume: 0.5 });

// Check for user interaction to unlock audio on the first click
this.input.once('pointerdown', () => {
    this.sound.unlock(); // Unlock audio for autoplay
    isAudioUnlocked = true; // Set a flag to ensure we can play sound
    console.log("Audio unlocked by user interaction.");
});
    

    // Remove any existing buttons
    if (retryButton) retryButton.destroy();
    if (finishButton) finishButton.destroy();

    createBackgroundLayers(this);
    setupGround(this);
    setupPlayer(this);
    setupAnimations(this);
    setupHitbox(this);
    setupInput(this);
    createForegroundLayer(this);

    // Initialize obstacle spawn timer
    obstacleSpawnTimer = this.time.addEvent({
        delay: spawnDelay,
        callback: spawnRandomObstacle,
        callbackScope: this,
        loop: true
    });

    this.time.addEvent({
    delay: 1000,    // 1 second
    callback: () => {
        score += 1;
        scoreText.setText('Score: ' + score);
    },
    loop: true
});

    // Initialize difficulty increase timer
    difficultyTimer = this.time.addEvent({
        delay: 5000, // Increase difficulty every 5 seconds
        callback: increaseDifficulty,
        callbackScope: this,
        loop: true
    });

    // Directly use `this` instead of creating a separate `scene` variable
    try {
        scoreText = this.add.text(10, 10, 'Score: 0', { fontSize: '32px', fill: '#FFF' });
        console.log("ScoreText Initialized Successfully:", scoreText);
    } catch (error) {
        console.error("Error initializing ScoreText:", error);
    }

}

function update(time) {
    if (!isDefeated) {
        updateBackgroundLayers();
        handlePlayerActions(time);
        updatePlayerAnimationSpeed();

        // Remove small obstacles that go off the left side of the screen
        smallObstacles = smallObstacles.filter(obstacle => {
            if (obstacle.x < -obstacle.width) {
                obstacle.destroy();
                return false;
            }
            return true;
        });

        // Remove tall obstacles that go off the left side of the screen
        tallObstacles = tallObstacles.filter(obstacle => {
            if (obstacle.x < -obstacle.width) {
                obstacle.destroy();
                return false;
            }
            return true;
        });
    }
}
function updatePlayerAnimationSpeed() {
    // Adjust the knightâ€™s animation frame rate based on parallaxSpeed
    const adjustedFrameRate = baseAnimationFrameRate * (parallaxSpeed / 10); // Scale by parallaxSpeed
    player.anims.msPerFrame = 2000 / adjustedFrameRate; // Adjust frame duration
}

        // Loading resources
        function loadBackgroundImages(scene) {
            const layers = [
                'Layer_0011_0.png', 'Layer_0010_1.png', 'Layer_0009_2.png', 'Layer_0008_3.png',
                'Layer_0007_Lights.png', 'Layer_0006_4.png', 'Layer_0005_5.png', 'Layer_0004_Lights.png',
                'Layer_0003_6.png', 'Layer_0002_7.png', 'Layer_0001_8.png', 'Layer_0000_9.png'
            ];

            layers.forEach((layer, index) => {
                scene.load.image(`backgroundLayer${index}`, `https://raw.githubusercontent.com/ML3782/Dissertation-Endless-Runner/main/Scene/${layer}`);
            });
        }

        function loadPlayerSprites(scene) {
            const spritesheets = [
                { key: 'playerRun', path: '_Run.png' },
                { key: 'playerJump', path: '_Jump.png' },
                { key: 'playerFallbetween', path: '_JumpFallInbetween.png' },
                { key: 'playerFall', path: '_Fall.png' },
                { key: 'playerAttack', path: '_Attack.png' }
            ];

            spritesheets.forEach(sprite => {
                scene.load.spritesheet(sprite.key, `https://raw.githubusercontent.com/ML3782/Dissertation-Endless-Runner/main/Character/${sprite.path}`, {
                    frameWidth: 120,
                    frameHeight: 80
                });
            });
        }

        // Setup functions
        function createBackgroundLayers(scene) {
            const backgroundConfig = [
                { key: 'backgroundLayer0', speed: 0.2 }, { key: 'backgroundLayer1', speed: 0.3 },
                { key: 'backgroundLayer2', speed: 0.4 }, { key: 'backgroundLayer3', speed: 0.5 },
                { key: 'backgroundLayer4', speed: 1.4 }, { key: 'backgroundLayer5', speed: 0.9 },
                { key: 'backgroundLayer6', speed: 1.0 }, { key: 'backgroundLayer7', speed: 1.3 },
                { key: 'backgroundLayer8', speed: 1.5 }, { key: 'backgroundLayer9', speed: 1.6 },
                { key: 'backgroundLayer10', speed: 1.8 }
            ];

            backgroundConfig.forEach(bg => {
                backgroundLayers.push({
                    layer: scene.add.tileSprite(GAME_WIDTH / 2, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT, bg.key),
                    speed: bg.speed
                });
            });
        }

        function createForegroundLayer(scene) {
            foregroundLayer = scene.add.tileSprite(GAME_WIDTH / 2, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT, 'backgroundLayer11');
            foregroundLayer.speed = 1.8;
        }

        function setupGround(scene) {
            ground = scene.physics.add.staticGroup();
            ground.create(GAME_WIDTH / 2, 742, 'ground').setDisplaySize(GAME_WIDTH, 0).refreshBody();
        }

        function setupPlayer(scene) {
            player = scene.physics.add.sprite(150, 600, 'playerRun').setScale(3);
            player.setBounce(0).setCollideWorldBounds(true);
            player.body.setSize(player.width * 0.11, player.height * 0.45);
            player.body.setOffset((player.width - player.body.width) / 2.10, (player.height - player.body.height) / 1);
            scene.physics.add.collider(player, ground);
        }

        function setupHitbox(scene) {
            hitbox = scene.physics.add.sprite(player.x + 50, player.y + 50, null);
            hitbox.body.setSize(75, 75);
            hitbox.setVisible(false);
            hitbox.body.enable = false;
            hitbox.body.allowGravity = false;
        }

        function setupAnimations(scene) {
            const animations = [
                { key: 'run', frames: 'playerRun', start: 0, end: 9, frameRate: 15, repeat: -1 },
                { key: 'jump', frames: 'playerJump', start: 0, end: 2, frameRate: 15 },
                { key: 'fallbetween', frames: 'playerFallbetween', start: 0, end: 1, frameRate: 10 },
                { key: 'fall', frames: 'playerFall', start: 0, end: 2, frameRate: 10 },
                { key: 'attack', frames: 'playerAttack', start: 0, end: 5, frameRate: 20 }
            ];

            animations.forEach(anim => {
                scene.anims.create({
                    key: anim.key,
                    frames: scene.anims.generateFrameNumbers(anim.frames, { start: anim.start, end: anim.end }),
                    frameRate: anim.frameRate,
                    repeat: anim.repeat || 0
                });
            });
        }

        function setupInput(scene) {
            cursors = scene.input.keyboard.createCursorKeys();
            wasdKeys = scene.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                attack: Phaser.Input.Keyboard.KeyCodes.D
            });
            attackKey = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            player.anims.play('run');
        }

        function setupGround(scene) {
    ground = scene.physics.add.staticGroup();
    ground.create(GAME_WIDTH / 2, 742, 'ground').setDisplaySize(GAME_WIDTH, 0).refreshBody();
}

// Spawn random obstacles up to the maximum limit
function spawnRandomObstacle() {
    const obstacleType = Phaser.Math.Between(0, 1);
    const minTallObstacleY = 700; // Adjust as needed
    const maxTallObstacleY = 750; // Adjust as needed

    if (obstacleType === 0 && smallObstacles.length < maxSmallObstacles) {
        const smallObstacle = this.physics.add.sprite(GAME_WIDTH, 700, 'smallObstacle').setScale(1.5);
        smallObstacle.setImmovable(true);
        smallObstacle.body.allowGravity = false;
        smallObstacle.setVelocityX(obstacleSpeed * baseSpeed);

        // Add overlap with hitbox to remove obstacle and increase score
        this.physics.add.overlap(hitbox, smallObstacle, () => {
            removeObstacleOnAttack(hitbox, smallObstacle);
            score += 100;   // Add 100 points
            scoreText.setText('Score: ' + score);
        }, null, this);

        this.physics.add.collider(smallObstacle, ground);
        this.physics.add.collider(player, smallObstacle, defeatPlayer, null, this);

        smallObstacles.push(smallObstacle);
    } else if (obstacleType === 1 && tallObstacles.length < maxTallObstacles) {
        const randomTallObstacleY = Phaser.Math.Between(minTallObstacleY, maxTallObstacleY);
        const tallObstacle = this.physics.add.sprite(GAME_WIDTH, randomTallObstacleY, 'smallObstacle').setScale(1.5, 7);
        tallObstacle.setImmovable(true);
        tallObstacle.body.allowGravity = false;
        tallObstacle.setVelocityX(obstacleSpeed * baseSpeed);

        this.physics.add.collider(tallObstacle, ground);
        this.physics.add.collider(player, tallObstacle, defeatPlayer, null, this);

        tallObstacles.push(tallObstacle);
    }

    // Update spawn timer
    obstacleSpawnTimer.reset({
        delay: spawnDelay,
        callback: spawnRandomObstacle,
        callbackScope: this,
        loop: true
    });
}

// Function to increase game difficulty over time
function increaseDifficulty() {
    // Decrease spawn delay down to a minimum limit
    if (spawnDelay > 600) {
        spawnDelay -= 90;
    }

    // Increase obstacle and player speed up to a maximum limit
    if (obstacleSpeed > -600) {
        obstacleSpeed -= 50;
    }

    // Increase parallax speed to simulate faster movement of the background and foreground
    if (parallaxSpeed < 10) { // Maximum parallax speed limit
        parallaxSpeed += 0.2;
    }
}
function updateBackgroundLayers() {
    // Use parallaxSpeed to update background and foreground layers
    backgroundLayers.forEach(bg => {
        bg.layer.tilePositionX += bg.speed * parallaxSpeed;
    });
    foregroundLayer.tilePositionX += foregroundLayer.speed * parallaxSpeed;
}

function handlePlayerActions(time) {
    if (player.body.blocked.down && !isJumping && !isAttacking) {
        player.anims.play('run', true);
    }

    handleJump(time);
    handleFallTransition();
    handleAttack();
}

function removeObstacleOnAttack(hitbox, obstacle) {
    if (smallObstacles.includes(obstacle) && isAttacking) {
        obstacle.destroy();
        smallObstacles = smallObstacles.filter(o => o !== obstacle);
    }
}

// function defeatPlayer(player, obstacle) {
//     if (!isAttacking) {
//         isDefeated = true;
//         player.setTint(0xff0000);
//         player.anims.stop();
//         player.setVelocity(0, 0);
//         console.log("Player defeated!");

//         obstacleSpawnTimer.remove();
//         difficultyTimer.remove();

//         showEndGameButtons(this);
//     }
// }
function defeatPlayer(player, obstacle) {
    // Skip defeat logic to make the player unkillable
    console.log("Collision with obstacle detected, but player is unkillable in debug mode.");
    // Simply return from the function to make the player unkillable for debugging purposes
    return;
}


function showEndGameButtons(scene) {
    retryButton = scene.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'Retry', {
        fontSize: '32px',
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 20, y: 10 },
    }).setOrigin(0.5).setInteractive();

    retryButton.on('pointerdown', () => {
        scene.scene.restart(); // Restart the scene
    });

    finishButton = scene.add.text(GAME_WIDTH - 20, 20, 'Finish', {
        fontSize: '24px',
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 10, y: 5 },
    }).setOrigin(1, 0).setInteractive();

    finishButton.on('pointerdown', () => {
        console.log("Finish Game");
    });
}
        // Game logic functions
        function updateBackgroundLayers() {
    // Use parallaxSpeed to update background and foreground layers
    backgroundLayers.forEach(bg => {
        bg.layer.tilePositionX += bg.speed * parallaxSpeed;
    });
    foregroundLayer.tilePositionX += foregroundLayer.speed * parallaxSpeed;
}

        function handlePlayerActions(time) {
            if (player.body.blocked.down && !isJumping && !isAttacking) {
                player.anims.play('run', true);
            }

            handleJump(time);
            handleFallTransition();
            handleAttack();
        }

        function handleJump(time) {
            if ((cursors.up.isDown || wasdKeys.up.isDown) && player.body.blocked.down && !isAttacking) {
                if (!isJumping) {
                    player.setVelocityY(jumpConfig.initialVelocity);
                    player.anims.play('jump', true);
                    jumpConfig.startTime = time;
                    isJumping = true;
                }
            }

            if (isJumping && (cursors.up.isDown || wasdKeys.up.isDown)) {
                const jumpDuration = time - jumpConfig.startTime;
                if (jumpDuration <= jumpConfig.holdTimeMax) {
                    player.setVelocityY(player.body.velocity.y + jumpConfig.holdBoost);
                }
            }

            if (isJumping && !(cursors.up.isDown || wasdKeys.up.isDown)) {
                isJumping = false;
            }
        }

        function handleFallTransition() {
            if (player.body.velocity.y > 0 && player.body.velocity.y < 600 && !player.body.blocked.down && player.anims.currentAnim.key !== 'fallbetween') {
                player.anims.play('fallbetween', true);
            }

            if (player.body.velocity.y >= 600 && !player.body.blocked.down && player.anims.currentAnim.key !== 'fall') {
                player.anims.play('fall', true);
            }
        }

        const handleAttack = () => {
    const isPeakOfJump = Math.abs(player.body.velocity.y) < 10 && !player.body.blocked.down;

    if ((cursors.right.isDown || attackKey.isDown) && !isAttacking && !isJumping && !isPeakOfJump &&
        !['jump', 'fallbetween', 'fall'].includes(player.anims.currentAnim.key)) {
        
        isAttacking = true;
        player.anims.play('attack', true);

        attackKey.on('down', () => {
                // Only play sound if audio has been unlocked
                if (isAudioUnlocked && swordSound) {
                    swordSound.play();
                } else {
                    console.warn("Sword sound is not ready or audio is locked by the browser.");
                }
            });

        hitbox.setPosition(player.x + 70, player.y + 50);
        hitbox.setVisible(true);
        hitbox.body.enable = true;

        player.once('animationcomplete-attack', () => {
            isAttacking = false;
            hitbox.setVisible(false);
            hitbox.body.enable = false;
            if (player.body.blocked.down) {
                player.anims.play('run', true);
            }
        });
    }
}
    </script>
</body>
</html>
